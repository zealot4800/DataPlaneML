# IPSA-ipbm

This is the updated version of the reference rP4 software switch (***ipbm*** - In-situ Programmable Behavioral Model). It consists of low-level dataplane which simulates the runtime programmable hardware and cosrresponding P4-rP4 compiler.

***ipbm*** is the experimental software used to verify the feasibility of runtime programming of dataplane, and it cannot compile the P4 files used in Tofino, but the P4 files that can compiled by p4c in **bmv2**.

This repository has four main components:
- ipbm-old: old version of ipbm (controller and dataplane)
- **sw-src**: updated version of ipbm (controller interface and dataplane)
- rp4c-old: old version of rP4 compiler
- **rP4-compiler**: updated version of rP4 compiler (P4->rP4, rP4->json, runtime controller)

# Attention Please
**We have refactored the software behavioral model and designed three simple use cases that can run on `ipbm`. Please refer to the branch [use_case_version](https://github.com/jijinfanhua/IPSA-ipbm/tree/use_case_version) for the new version and use case running. The compiler hasn't been updated.**

# Dependencies
- Update the gcc version above 8, so that `std2a` can be used to compile the compiler source code.

- Install cmake, [pcap](https://www.tcpdump.org/), [yaml-cpp](https://github.com/jbeder/yaml-cpp), [glog](https://github.com/google/glog), [gflags](https://github.com/gflags/gflags)

- Install [p4c](https://github.com/p4lang/p4c), so that the intermmediate representation can be generated.

- Install [grpc](https://github.com/grpc/grpc), so that the controller can connect to the dataplane.

# Front-end compiler build and run
For the rP4 front-end compiler,
```shell
cd rP4-compiler/p4r/
make
``` 
after that, the front-end compiler ***p4r*** is generated.Use the command below to compile the json file generated by *p4c* to *.rp4*.
```shell
./p4r <p4ir json> <rp4 name>
```

# Back-end compiler build and run
For the rP4 back-end compiler,
```shell
cd rP4-compiler/rp4c
make
```
after that, the back-end compiler ***rp4_compiler*** and the runtime compiler ***rp4c*** are generated. Use the command below to compile the rP4 file to json that can be recognized by the dataplane.
```shell
./rp4_compiler <rp4 file> <ipbm json file>
```
As for runtime compiler, use the command below to update the dataplane,
```shell
compile <rp4 updated file> <rp4 update json>
```
and use `table_add` and `table_del` for table entry modification, 
```shell
table_add <table_name> <action_name> <key> => <action_para>
table_del <table_name> <key>
```

# Runtime programmable dataplane
For the runtime programmable dataplane, 
```shell
mkdir -p build && cd build
cmake ..
make -j
```
We should build the network topology with `ip netns`. The example topologies can be seen in `sw-src/script`.

To run the switch and load initial configuration, 
```shell
cd build
sudo bash ../sw-src/script/router.sh
sudo ip netns exec R2 ./bin/main -logtostderr=1 -ifconf ../sw-src/conf/router.yml
sudo ip netns exec R2 ./bin/ctrl_init_dataplane ../sw-src/controller/basic.json
sudo ip netns exec R2 ./bin/ctrl_mod_table <table entry json generated by `rp4c`>
# connectivity test
sudo ip netns exec R1 ping 10.0.2.50 -c 4
sudo ip netns exec R3 ping 10.0.1.50 -c 4
```
use the command below to update.
```shell
sudo ip netns exec R2 ./bin/ctrl_init_dataplane <updated rp4 json>
```

# Neuron-based primitive pipeline
This repo ships a neural-classifier demo that exercises the neuron primitive blocks built into ipbm. The supporting JSON overlays live under `sw-src/tables/`:
- `metadata_context.json` – extended metadata layout plus `neuron_primitive_contexts`.
- `sigmoid_table.json` – sigmoid/activation lookup table.
- `processor.json` – processors 0–9 that chain the neuron operations described in `neuron_primitive.md`.

Deploying the pipeline on top of the normal `classifier_ipbm.json` dataplane:
1. Compile classifier.p4 to BMv2 JSON
   ```bash
   p4c --target bmv2 --arch v1model --std p4-16 sw-src/examples/classifier.p4 --output build/classifier-bmv2.json
   ```
2. Convert BMv2 JSON to rP4
   ```bash
   ./rP4-compiler/p4r/p4r build/classifier-bmv2.json build/classifier.rp4
   ```
3. Run the rP4 back-end to get the ipbm JSON
   ```bash
   ./rP4-compiler/rp4c/rp4_compiler build/classifier.rp4 build/classifier_ipbm.json
   ```
4. Merge neuron overlays using the new base
   ```bash
   python3 scripts/merge_neuron_tables.py --base build/classifier_ipbm.json --output build/neuron_pipeline.json
5. Push the merged configuration through the controller:
   ```bash
   cd build
   sudo ip netns exec R2 ./bin/ctrl_init_dataplane ../build/neuron_pipeline.json
   ```
   The gRPC controller updates metadata, sigmoid tables, and processor definitions without restarting `main`.
3. Review `neuron_primitive.md` for a packet-level walkthrough of how each processor consumes or produces the metadata fields defined in the overlays.

Whenever you tweak weights, activation tables, or metadata placement, edit the files in `sw-src/tables/`, rerun `scripts/merge_neuron_tables.py`, and reapply the result with `ctrl_init_dataplane`.
